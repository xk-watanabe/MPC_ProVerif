(* channel *)
free p1_p2: channel.
free p1_p3: channel.
free p2_p3: channel.

(* secret sharing *)
type unshare.
type share.
fun share1(unshare): share.
fun share2(unshare): share.
fun share3(unshare): share.
letfun secretsharing(s:unshare) = (share1(s),share2(s),share3(s)).

(* property of linear secret sharing *)
fun addition(unshare,unshare): unshare.
fun addition_share(share,share): share.
fun addition_share_unshare(share,unshare): share.
fun subtraction(unshare,unshare): unshare.
fun subtraction_share(share,share): share.
fun multiplication(unshare,unshare): unshare.
fun multiplication_share_unshare(share,unshare): share.

(* commitment *)
fun commit(share): bitstring.
reduc forall x:share; decommit(x,commit(x)) = true.

equation
    forall e,f:unshare; addition(f,subtraction(e,f)) = e;
    forall g,h:unshare; addition_share_unshare(share1(g),h) = share1(addition(g,h));
    forall i,j:unshare; addition_share_unshare(share2(i),j) = share2(addition(i,j));
    forall k,l:unshare; addition_share_unshare(share3(k),l) = share3(addition(k,l));
    forall m,n:unshare; addition_share(share1(m),share1(n)) = share1(addition(m,n));
    forall o,p:unshare; addition_share(share2(o),share2(p)) = share2(addition(o,p));
    forall q,r:unshare; addition_share(share3(q),share3(r)) = share3(addition(q,r));
    forall s,t:unshare; multiplication_share_unshare(share1(s),t) = share1(multiplication(s,t));
    forall u,v:unshare; multiplication_share_unshare(share2(u),v) = share2(multiplication(u,v));
    forall w,x:unshare; multiplication_share_unshare(share3(w),x) = share3(multiplication(w,x));
    forall y,z:unshare; subtraction_share(share1(y),share1(z)) = share1(subtraction(y,z));
    forall aa,ab:unshare; subtraction_share(share2(aa),share2(ab)) = share2(subtraction(aa,ab));
    forall ac,ad:unshare; subtraction_share(share3(ac),share3(ad)) = share3(subtraction(ac,ad))
    .

reduc forall x:unshare; recon(share1(x),share2(x),share3(x))=x.

free y: unshare[private].
free alpha: unshare[private].

event end_1(unshare).
event end_2(unshare).
event end_3(unshare).
event commitment_1(share).
event commitment_2(share).
event commitment_3(share).
query x:unshare; (event(end_1(x)) && event(end_2(x)) && event(end_3(x))) ==> (event(commitment_1(share1(x))) && event(commitment_2(share2(x))) && event(commitment_3(share3(x)))).
query x:unshare; (event(end_2(x)) && event(end_3(x))) ==> event(commitment_1(share1(x))).

let p1(y_1:share, m_1:share, alpha_1:share)=
    out(p1_p2,y_1);
    out(p1_p3,y_1);
    in(p1_p2,y_2:share);
    in(p1_p3,y_3:share);
    let y' = recon(y_1,y_2,y_3) in
    let delta_1 = subtraction_share(m_1,multiplication_share_unshare(alpha_1,y')) in
    let commit_1 = commit(delta_1) in
    event commitment_1(delta_1);
    out(p1_p2,commit_1);
    out(p1_p3,commit_1);
    in(p1_p2,commit_2:bitstring);
    in(p1_p3,commit_3:bitstring);
    out(p1_p2,delta_1);
    out(p1_p3,delta_1);
    in(p1_p2,delta_2:share);
    let (=true) = decommit(delta_2,commit_2) in
    in(p2_p3,delta_3:share);
    let (=true) = decommit(delta_3,commit_3) in
    if(recon(delta_1,delta_2,delta_3) = subtraction(multiplication(alpha,y),multiplication(alpha,y'))) then
    event end_1(recon(delta_1,delta_2,delta_3)).

let p2(y_2:share, m_2:share, alpha_2:share)=
    out(p1_p2,y_2);
    out(p2_p3,y_2);
    in(p1_p2,y_1:share);
    in(p2_p3,y_3:share);
    let y' = recon(y_1,y_2,y_3) in
    in(p1_p2,commit_1:bitstring);
    let delta_2 = subtraction_share(m_2,multiplication_share_unshare(alpha_2,y')) in
    let commit_2 = commit(delta_2) in
    event commitment_2(delta_2);
    out(p1_p2,commit_2);
    out(p2_p3,commit_2);
    in(p1_p3,commit_3:bitstring);
    in(p1_p2,delta_1:share);
    let (=true) = decommit(delta_1,commit_1) in
    out(p1_p2,delta_2);
    out(p2_p3,delta_2);
    in(p2_p3,delta_3:share);
    let (=true) = decommit(delta_3,commit_3) in
    if(recon(delta_1,delta_2,delta_3) = subtraction(multiplication(alpha,y),multiplication(alpha,y'))) then
    event end_2(recon(delta_1,delta_2,delta_3)).

let p3(y_3:share, m_3:share, alpha_3:share)=
    out(p1_p3,y_3);
    out(p2_p3,y_3);
    in(p1_p3,y_1:share);
    in(p2_p3,y_2:share);
    let y' = recon(y_1,y_2,y_3) in
    in(p1_p3,commit_1:bitstring);
    in(p2_p3,commit_2:bitstring);
    let delta_3 = subtraction_share(m_3,multiplication_share_unshare(alpha_3,y')) in
    let commit_3 = commit(delta_3) in
    event commitment_3(delta_3);
    out(p1_p3,commit_3);
    out(p2_p3,commit_3);
    in(p1_p3,delta_1:share);
    let (=true) = decommit(delta_1,commit_1) in
    in(p2_p3,delta_2:share);
    let (=true) = decommit(delta_2,commit_2) in
    out(p1_p3,delta_3);
    out(p2_p3,delta_3);
    if(recon(delta_1,delta_2,delta_3) = subtraction(multiplication(alpha,y),multiplication(alpha,y'))) then
    event end_3(recon(delta_1,delta_2,delta_3)).

process
    let (y_1:share, y_2:share, y_3:share) = secretsharing(y) in
    let (alpha_1:share, alpha_2:share, alpha_3:share) = secretsharing(alpha) in
    let (m_1:share, m_2:share, m_3:share) = secretsharing(multiplication(alpha,y)) in
    (
        p1(y_1,m_1,alpha_1)
        |
        p2(y_2,m_2,alpha_2)
        |
        p3(y_3,m_3,alpha_3)
    )