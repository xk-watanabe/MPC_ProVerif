set attacker = passive.
free c: channel.
free p1_p2:channel.
free p1_p3:channel.
free p2_p3:channel.

(* secret sharing *)
type unshare.
type share.
fun share1(unshare): share.
fun share2(unshare): share.
fun share3(unshare): share.
letfun secretsharing(s:unshare) = (share1(s),share2(s),share3(s)).

(* property of linear secret sharing *)
fun addition(unshare,unshare): unshare.
fun addition_share(share,share): share.
fun addition_share_unshare(share,unshare): share.
fun subtraction(unshare,unshare):unshare.
fun subtraction_share(share,share): share.
fun multiplication(unshare,unshare): unshare.
fun multiplication_share_unshare(share,unshare): share.

equation
    forall e,f:unshare; addition(f,subtraction(e,f)) = e;
    forall g,h:unshare; addition_share_unshare(share1(g),h) = share1(addition(g,h));
    forall i,j:unshare; addition_share_unshare(share2(i),j) = share2(addition(i,j));
    forall k,l:unshare; addition_share_unshare(share3(k),l) = share3(addition(k,l));
    forall m,n:unshare; addition_share(share1(m),share1(n)) = share1(addition(m,n));
    forall o,p:unshare; addition_share(share2(o),share2(p)) = share2(addition(o,p));
    forall q,r:unshare; addition_share(share3(q),share3(r)) = share3(addition(q,r));
    forall s,t:unshare; multiplication_share_unshare(share1(s),t) = share1(multiplication(s,t));
    forall u,v:unshare; multiplication_share_unshare(share2(u),v) = share2(multiplication(u,v));
    forall w,x:unshare; multiplication_share_unshare(share3(w),x) = share3(multiplication(w,x));
    forall y,z:unshare; subtraction_share(share1(y),share1(z)) = share1(subtraction(y,z));
    forall aa,ab:unshare; subtraction_share(share2(aa),share2(ab)) = share2(subtraction(aa,ab));
    forall ac,ad:unshare; subtraction_share(share3(ac),share3(ad)) = share3(subtraction(ac,ad))
    .

reduc forall x:unshare; recon(share1(x),share2(x),share3(x))=x.

free x1: unshare[private].
free r: unshare[private].
event recon_x1.
query attacker(x1).
query event(recon_x1).
    
let p1(r_1:share)=
    in(p1_p2,r_2:share);
    in(p1_p3,r_3:share);
    let r' = recon(r_1,r_2,r_3) in
    let ep = subtraction(x1,r') in
    out(p1_p2,ep);
    out(p1_p3,ep);
    let x1_share_1 = addition_share_unshare(r_1,ep) in
    in(p1_p2,x1_share_2:share);
    in(p1_p3,x1_share_3:share);
    let (=x1) = recon(x1_share_1,x1_share_2,x1_share_3) in
    event recon_x1.

let p2(r_2:share)=
    out(p1_p2,r_2);
    in(p1_p2,ep:unshare);
    let x1_share_2 = addition_share_unshare(r_2,ep) in
    out(p1_p2,x1_share_2);
    out(c,x1_share_2).


let p3(r_3:share)=
    out(p1_p3,r_3);
    in(p1_p3,ep:unshare);
    let x1_share_3 = addition_share_unshare(r_3,ep) in
    out(p1_p3,x1_share_3);
    out(c,x1_share_3).

process
    let (r_1:share,r_2:share,r_3:share) = secretsharing(r) in
    (
        p1(r_1)
        |
        p2(r_2)
        |
        p3(r_3)
    )