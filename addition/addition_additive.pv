set attacker = passive.
free c: channel.
free p1_p2:channel.
free p1_p3:channel.
free p2_p3:channel.

(* secret sharing *)
type unshare.
type share.
fun share1(unshare): share.
fun share2(unshare): share.
fun share3(unshare): share.
letfun secretsharing(s:unshare) = (share1(s),share2(s),share3(s)).

(* property of linear secret sharing *)
fun addition(unshare,unshare): unshare.
fun addition_share(share,share): share.
fun addition_share_unshare(share,unshare): share.
fun subtraction(unshare,unshare): unshare.
fun subtraction_share(share,share): share.
fun subtraction_unshare_share(unshare,share): share.
fun multiplication(unshare,unshare): unshare.
fun multiplication_share_unshare(share,unshare): share.

fun recon(share,share,share): unshare
    reduc forall x:unshare; recon(share1(x),share2(x),share3(x))=x
        otherwise forall x,r:unshare; recon(addition_share_unshare(share1(r),subtraction(x,r)),share2(r),share3(r)) = x
        otherwise forall x,y:unshare; recon(share1(addition(x,y)),share2(x),share3(x))=addition(x,y)
        otherwise forall x,y,r1,r2:unshare; 
            recon(addition_share(addition_share_unshare(share1(r1),subtraction(x,r1)),addition_share_unshare(share1(r2),subtraction(y,r2))),addition_share(share2(r1),share2(r2)),addition_share(share3(r1),share3(r2)))=addition(x,y) .

equation
    forall g,h:unshare; addition_share_unshare(share1(g),h) = share1(addition(g,h));
    (* forall i,j:unshare; addition_share_unshare(share2(i),j) = share2(addition(i,j)); *)
    (* forall k,l:unshare; addition_share_unshare(share3(k),l) = share3(addition(k,l)); *)
    forall m,n:unshare; addition_share(share1(m),share1(n)) = share1(addition(m,n));
    forall o,p:unshare; addition_share(share2(o),share2(p)) = share2(addition(o,p));
    forall q,r:unshare; addition_share(share3(q),share3(r)) = share3(addition(q,r));
    forall s,t:unshare; multiplication_share_unshare(share1(s),t) = share1(multiplication(s,t));
    forall u,v:unshare; multiplication_share_unshare(share2(u),v) = share2(multiplication(u,v));
    forall w,x:unshare; multiplication_share_unshare(share3(w),x) = share3(multiplication(w,x))
    .

free r_1: unshare[private].
free r_2: unshare[private].
free x_1: unshare[private].
free x_2: unshare[private].
query attacker(x_1).
query attacker(x_2).
query attacker(addition(x_1,x_2)).
    
let p1(r1_1:share,r2_1:share)=
    (* Share x1 *)
    in(p1_p2,r1_2:share);
    in(p1_p3,r1_3:share);
    let r1 = recon(r1_1,r1_2,r1_3) in
    let ep1 = subtraction(x_1,r1) in
    out(p1_p2,ep1);
    out(p1_p3,ep1);
    let x1_share_1 = addition_share_unshare(r1_1,ep1) in
    (* Share x2 *)
    out(p1_p2,r2_1);
    in(p1_p2,ep2:unshare);
    let x2_share_1 = addition_share_unshare(r2_1,ep2) in
    (* Calculate x1+x2 on share *)
    let addition_1 = addition_share(x1_share_1,x2_share_1) in
    out(c,addition_1).

let p2(r1_2:share,r2_2:share)=
    (* Share x1 *)
    out(p1_p2,r1_2);
    in(p1_p2,ep1:unshare);
    let x1_share_2 = r1_2 in
    (* Share x2 *)
    in(p1_p2,r2_1:share);
    in(p2_p3,r2_3:share);
    let r2 = recon(r2_1,r2_2,r2_3) in
    let ep2 = subtraction(x_2,r2) in
    out(p1_p2,ep2);
    out(p2_p3,ep2);
    let x2_share_2 = r2_2 in
    (* Calculate x1+x2 on share *)
    let addition_2 = addition_share(x1_share_2,x2_share_2) in
    out(c,addition_2).

let p3(r1_3:share,r2_3:share)=
    (* Share x1 *)
    out(p1_p3,r1_3);
    in(p1_p3,ep1:unshare);
    let x1_share_3 = r1_3 in
    (* Share x2 *)
    out(p2_p3,r2_3);
    in(p2_p3,ep2:unshare);
    let x2_share_3 = r2_3 in
    (* Calculate x1+x2 on share *)
    let addition_3 = addition_share(x1_share_3,x2_share_3) in
    out(c,addition_3).

process
    let (r1_1:share,r1_2:share,r1_3:share) = secretsharing(r_1) in
    let (r2_1:share,r2_2:share,r2_3:share) = secretsharing(r_2) in
    (
        p1(r1_1,r2_1)
        |
        p2(r1_2,r2_2)
        |
        p3(r1_3,r2_3)
    )